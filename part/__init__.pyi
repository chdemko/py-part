from abc import abstractmethod, ABCMeta
from collections.abc import Set, MutableSet, Mapping, MutableMapping
from typing import (
    Optional,
    Any,
    Iterator,
    Union,
    Tuple,
    Iterable,
    KeysView,
    ItemsView,
    ValuesView,
)

INFINITY: Any = ...

class Atomic:
    @abstractmethod
    def __str__(self) -> str: ...
    @abstractmethod
    def __eq__(self, other) -> bool: ...
    @abstractmethod
    def __lt__(self, other) -> bool: ...
    @abstractmethod
    def __gt__(self, other) -> bool: ...
    @abstractmethod
    def __hash__(self) -> int: ...
    @abstractmethod
    def __bool__(self) -> bool: ...
    @abstractmethod
    def __or__(self, other) -> FrozenIntervalSet: ...
    @abstractmethod
    def __and__(self, other) -> FrozenIntervalSet: ...
    @abstractmethod
    def __invert__(self) -> FrozenIntervalSet: ...
    @abstractmethod
    def meets(self, other: Atomic, strict: bool = True) -> bool: ...
    @abstractmethod
    def overlaps(self, other: Atomic, strict: bool = True) -> bool: ...
    @abstractmethod
    def starts(self, other: Atomic, strict: bool = True) -> bool: ...
    @abstractmethod
    def during(self, other: Atomic, strict: bool = True) -> bool: ...
    @abstractmethod
    def finishes(self, other: Atomic, strict: bool = True) -> bool: ...

class Empty(Atomic):
    def __str__(self) -> str: ...
    def __eq__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __or__(self, other) -> FrozenIntervalSet: ...
    def __and__(self, other) -> FrozenIntervalSet: ...
    def __invert__(self) -> FrozenIntervalSet: ...
    def meets(self, other: Atomic, strict: bool = True) -> bool: ...
    def overlaps(self, other: Atomic, strict: bool = True) -> bool: ...
    def starts(self, other: Atomic, strict: bool = True) -> bool: ...
    def during(self, other: Atomic, strict: bool = True) -> bool: ...
    def finishes(self, other: Atomic, strict: bool = True) -> bool: ...

EMPTY: Empty = ...

IntervalTuple = Union[
    Tuple[Any, Any],
    Tuple[Optional[bool], Any, Any],
    Tuple[Any, Any, Optional[bool]],
    Tuple[Optional[bool], Any, Any, Optional[bool]],
]

class Mark:
    def __str__(self) -> str: ...
    def near(self, other: Mark) -> bool: ...

class Interval(Atomic):
    def __init__(
        self,
        lower: Optional[Any] = None,
        upper: Optional[Any] = None,
        left: bool = True,
        right: bool = False,
    ) -> None: ...
    def __str__(self) -> str: ...
    def __eq__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __or__(self, other) -> FrozenIntervalSet: ...
    def __and__(self, other) -> FrozenIntervalSet: ...
    def __invert__(self) -> FrozenIntervalSet: ...
    def meets(self, other: Atomic, strict: bool = True) -> bool: ...
    def overlaps(self, other: Atomic, strict: bool = True) -> bool: ...
    def starts(self, other: Atomic, strict: bool = True) -> bool: ...
    def during(self, other: Atomic, strict: bool = True) -> bool: ...
    def finishes(self, other: Atomic, strict: bool = True) -> bool: ...
    @staticmethod
    def from_tuple(item: IntervalTuple) -> Interval: ...
    @staticmethod
    def from_value(value: Any) -> Interval: ...
    @staticmethod
    def upper_limit(
        value: Optional[Any] = None, closed: Optional[bool] = None
    ) -> Interval: ...
    @staticmethod
    def lower_limit(
        value: Optional[Any] = None, closed: Optional[bool] = True
    ) -> Interval: ...
    @property
    def lower(self) -> Mark: ...
    @property
    def lower_value(self) -> Any: ...
    @property
    def lower_closed(self) -> bool: ...
    @property
    def upper(self) -> Mark: ...
    @property
    def upper_value(self) -> Any: ...
    @property
    def upper_closed(self) -> bool: ...

IntervalValue = Union[Interval, IntervalTuple]

FULL: Interval = ...

class IntervalSet(Set, metaclass=ABCMeta):
    def __str__(self) -> str: ...
    def __eq__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index) -> Interval: ...
    def __iter__(self) -> Iterator[Interval]: ...
    def __and__(self, other) -> IntervalSet: ...
    def __or__(self, other) -> IntervalSet: ...
    def __sub__(self, other) -> IntervalSet: ...
    def __xor__(self, other) -> IntervalSet: ...
    def __invert__(self) -> IntervalSet: ...
    def __reversed__(self) -> Iterator[Interval]: ...
    def isdisjoint(self, other: Iterable[IntervalValue]) -> bool: ...
    def issubset(self, other: Iterable[IntervalValue]) -> bool: ...
    def issuperset(self, other: Iterable[IntervalValue]) -> bool: ...
    def intersection(self, *args: Iterable[IntervalValue]) -> IntervalSet: ...
    def union(self, *args: Iterable[IntervalValue]) -> IntervalSet: ...
    def difference(self, *args: Iterable[IntervalValue]) -> IntervalSet: ...
    def symmetric_difference(self, other: Iterable[IntervalValue]) -> IntervalSet: ...
    def copy(self) -> IntervalSet: ...
    def select(
        self, value: IntervalValue, strict: bool = True
    ) -> Iterator[Interval]: ...

class FrozenIntervalSet(IntervalSet):
    def __init__(self, iterable: Optional[Iterable[IntervalValue]] = None) -> None: ...
    def __hash__(self) -> int: ...
    def __contains__(self, item) -> bool: ...

class MutableIntervalSet(IntervalSet, MutableSet):
    def __init__(self, iterable: Optional[Iterable[IntervalValue]] = None) -> None: ...
    def __contains__(self, item) -> bool: ...
    def __ior__(self, other) -> MutableIntervalSet: ...
    def __iand__(self, other) -> MutableIntervalSet: ...
    def __isub__(self, other) -> MutableIntervalSet: ...
    def __ixor__(self, other) -> MutableIntervalSet: ...
    def update(self, *args: Iterable[IntervalValue]) -> None: ...
    def intersection_update(self, *args: Iterable[IntervalValue]) -> None: ...
    def difference_update(self, *args: Iterable[IntervalValue]) -> None: ...
    def symmetric_difference_update(self, other: Iterable[IntervalValue]) -> None: ...
    def add(self, value: IntervalValue) -> None: ...
    def remove(self, value: IntervalValue) -> None: ...
    def discard(self, value: IntervalValue) -> None: ...
    def pop(self) -> Interval: ...
    def clear(self) -> None: ...

class IntervalDict(Mapping, metaclass=ABCMeta):
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Interval]: ...
    def __getitem__(self, key: Union[slice, IntervalValue]) -> Any: ...
    def __contains__(self, key: Any) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def keys(self) -> KeysView[Interval]: ...
    def items(self) -> ItemsView[Interval, Any]: ...
    def values(self) -> ValuesView[Any]: ...
    def get(self, key: IntervalValue, default=None) -> Any: ...
    def copy(self) -> IntervalSet: ...
    def select(
        self, value: IntervalValue, strict: bool = True
    ) -> Iterator[Tuple[Interval, Any]]: ...

class FrozenIntervalDict(IntervalDict):
    def __init__(
        self,
        iterable: Optional[Union[Mapping, Iterable[Tuple[IntervalValue, Any]]]] = None,
    ) -> None: ...

class MutableIntervalDict(IntervalDict, MutableMapping):
    def __init__(
        self,
        iterable: Optional[Union[Mapping, Iterable[Tuple[IntervalValue, Any]]]] = None,
    ) -> None: ...
    def __setitem__(self, key: Union[slice, IntervalValue], value) -> None: ...
    def __delitem__(self, key: Union[slice, IntervalValue]) -> None: ...
